#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_shader_image_load_formatted : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "denoise_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

void main() {
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    if (!inBound(coord, rtxState.size) || rtxState.denoise == 0) {
        return;
    }

    vec3 albedo; vec3 norm; vec3 pos; uint matHash;
    loadThisGeometry(coord, albedo, norm, pos, matHash);

    if (rtxState.denoiseLevel == 0) {
        vec3 res = waveletFilter(thisIndirectResultImage, coord, norm, pos, matHash,
            rtxState.sigLuminIndirect, rtxState.sigNormalIndirect, rtxState.sigDepthIndirect, 0);
        imageStore(denoiseTempA, coord, vec4(res, 1.0));
    }
    else if (rtxState.denoiseLevel == 1) {
        vec3 res = waveletFilter(denoiseTempA, coord, norm, pos, matHash,
            rtxState.sigLuminIndirect, rtxState.sigNormalIndirect, rtxState.sigDepthIndirect, 1);
        imageStore(denoiseTempB, coord, vec4(res, 1.0));
    }
    else if (rtxState.denoiseLevel == 2) {
        vec3 res = waveletFilter(denoiseTempB, coord, norm, pos, matHash,
            rtxState.sigLuminIndirect, rtxState.sigNormalIndirect, rtxState.sigDepthIndirect, 2);
        imageStore(denoiseTempA, coord, vec4(res, 1.0));
    }
    else if (rtxState.denoiseLevel == 3) {
        vec3 res = waveletFilter(denoiseTempA, coord, norm, pos, matHash,
            rtxState.sigLuminIndirect, rtxState.sigNormalIndirect, rtxState.sigDepthIndirect, 3);
        imageStore(denoiseTempB, coord, vec4(res, 1.0));
    }
    else if (rtxState.denoiseLevel == 4) {
        vec3 res = waveletFilter(denoiseTempB, coord, norm, pos, matHash,
            rtxState.sigLuminIndirect, rtxState.sigNormalIndirect, rtxState.sigDepthIndirect, 4);
        imageStore(denoiseTempA, coord, vec4(res, 1.0));
    }
    else if (rtxState.denoiseLevel == 5) {
        vec3 res = LDRToHDR(waveletFilter(denoiseTempA, coord, norm, pos, matHash,
            rtxState.sigLuminIndirect, rtxState.sigNormalIndirect, rtxState.sigDepthIndirect, 5)) * albedo;
        imageStore(thisIndirectResultImage, coord, vec4(res, 1.0));
    }
}
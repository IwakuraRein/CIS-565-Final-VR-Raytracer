/*
 * Copyright (c) 2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

//-------------------------------------------------------------------------------------------------
// Ray Query compute shader implementating the path tracer.

#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "host_device.h"

layout(push_constant) uniform _RtxState {
  RtxState rtxState;
};

#include "globals.glsl"

PtPayload prd;
ShadowHitPayload shadow_payload;
ivec2 imageCoords;

#include "layouts.glsl"
#include "random.glsl"
#include "common.glsl"
#include "traceray_rq.glsl"

#include "pathtrace.glsl"

#define FIREFLIES 1
#define TILED_MULTIBOUNCE 1
#define FETCH_GEOM_CHECK_4_SUBPIXELS 1
#define PRE_UPSCALE 1

#ifndef SWIZZLED
layout(local_size_x = 8, local_size_y = 8) in;
#else
layout(local_size_x = 32, local_size_y = 2) in;
#extension GL_EXT_shader_8bit_storage : enable  // Using uint_8 ...
ivec2 SampleSizzled() {
  // Sampling Swizzling
  // Convert 32x2 to 8x8, where the sampling will follow how invocation are done in a subgroup.
  // layout(local_size_x = 32, local_size_y = 2) in;
  ivec2 base = ivec2(gl_WorkGroupID.xy) * 8;
  ivec2 subset = ivec2(int(gl_LocalInvocationID.x) & 1, int(gl_LocalInvocationID.x) / 2);
  subset += gl_LocalInvocationID.x >= 16 ? ivec2(2, -8) : ivec2(0, 0);
  subset += ivec2(gl_LocalInvocationID.y * 4, 0);
  return base + subset;
}
#endif

#if TILED_MULTIBOUNCE
shared bool multiBounce;
#else
const bool multiBounce = true;
#endif

const float MultiBounceProb = 0.25;

ivec2 indSize() {
    return rtxState.size / 2;
}

#if !FETCH_GEOM_CHECK_4_SUBPIXELS
bool getStateFromGbuffer(Ray ray, out State state, out float depth) {
  uvec4 gInfo = imageLoad(thisGbuffer, imageCoords * 2);
  depth = uintBitsToFloat(gInfo.x);
  if(depth >= INFINITY - EPS * 10.0)
    return false;
  state.position = ray.origin + ray.direction * depth;
  state.normal = decompress_unit_vec(gInfo.y);
  state.ffnormal = dot(state.normal, ray.direction) <= 0.0 ? state.normal : -state.normal;

  // Filling material structures
  state.mat.albedo = unpackUnorm4x8(gInfo.w).xyz;
  vec4 matInfo = unpackUnorm4x8(gInfo.z);
  state.mat.metallic = matInfo.x;
  state.mat.roughness = matInfo.y;
  state.mat.ior = matInfo.z * MAX_IOR_MINUS_ONE + 1.f;
  state.mat.transmission = matInfo.w;
  state.matID = gInfo.w >> 24; // hashed matarial id
  return true;
}
#else
bool getStateFromGbuffer(Ray ray, out State state, out float depth) {
  uvec4 gInfo00 = imageLoad(thisGbuffer, imageCoords * 2 + ivec2(0, 0));
  uvec4 gInfo10 = imageLoad(thisGbuffer, imageCoords * 2 + ivec2(1, 0));
  uvec4 gInfo11 = imageLoad(thisGbuffer, imageCoords * 2 + ivec2(1, 1));
  uvec4 gInfo01 = imageLoad(thisGbuffer, imageCoords * 2 + ivec2(0, 1));

  depth = (uintBitsToFloat(gInfo00.x) + uintBitsToFloat(gInfo10.x) + uintBitsToFloat(gInfo11.x) +
    uintBitsToFloat(gInfo01.x)) * 0.25;

  if(depth >= INFINITY - EPS * 10.0)
    return false;

  state.position = ray.origin + ray.direction * depth;
  state.normal = (decompress_unit_vec(gInfo00.y) + decompress_unit_vec(gInfo10.y) + decompress_unit_vec(gInfo11.y) +
    decompress_unit_vec(gInfo01.y)) * 0.25;
  state.ffnormal = dot(state.normal, ray.direction) <= 0.0 ? state.normal : -state.normal;

  // Filling material structures
  state.mat.albedo = (unpackUnorm4x8(gInfo00.w).xyz + unpackUnorm4x8(gInfo10.w).xyz +
    unpackUnorm4x8(gInfo11.w).xyz + unpackUnorm4x8(gInfo01.w).xyz) * 0.25;

  vec4 matInfo00 = unpackUnorm4x8(gInfo00.z);
  vec4 matInfo10 = unpackUnorm4x8(gInfo10.z);
  vec4 matInfo11 = unpackUnorm4x8(gInfo11.z);
  vec4 matInfo01 = unpackUnorm4x8(gInfo01.z);

  state.mat.metallic = (matInfo00.x + matInfo10.x + matInfo11.x + matInfo01.x) * 0.25;
  state.mat.roughness = (matInfo00.y + matInfo10.y + matInfo11.y + matInfo01.y) * 0.25;
  state.mat.ior = (matInfo00.z + matInfo10.z + matInfo11.z + matInfo01.z) * 0.25 * MAX_IOR_MINUS_ONE + 1.f;
  state.mat.transmission = (matInfo00.w + matInfo01.w + matInfo11.w + matInfo10.w) * 0.25;

  float r = rand(prd.seed);
  if (r < 0.25) {
    state.matID = gInfo00.w >> 24;
  }
  else if (r < 0.5) {
    state.matID = gInfo10.w >> 24;
  }
  else if (r < 0.75) {
    state.matID = gInfo11.w >> 24;
  }
  else {
    state.matID = gInfo01.w >> 24;
  }
  return true;
}
#endif
uvec2 encodeMaterialInfo(State state) {
    uvec2 matInfo;
    matInfo.x = packUnorm4x8(vec4(state.mat.metallic, state.mat.roughness, (state.mat.ior-1.0) / MAX_IOR_MINUS_ONE, state.mat.transmission));
    matInfo.y = packUnorm4x8(vec4(state.mat.albedo, 1.0)) & 0xFFFFFF; //agbr
    matInfo.y += hash8bit(state.matID);
    return matInfo;
}

float MIS(float f, float g) {
    return (rtxState.MIS > 0) ? powerHeuristic(f, g) : 1.0;
}

float pHatIndirect(GISample giSample, State state, vec3 wo) {
    return resvToScalar(giSample.L);

    vec3 wi = normalize(giSample.xs - giSample.xv);
    return resvToScalar(giSample.L * BSDF(state, wo, state.ffnormal, wi) * satDot(giSample.nv, wi));
}

float bigWIndirect(IndirectReservoir resv, State state, vec3 wo) {
    return resv.weight / (pHatIndirect(resv.giSample, state, wo) * float(resv.num));
}

bool findTemporalNeighbor(
    vec3 norm, float depth, float reprojDepth, uint matId, ivec2 lastCoord, inout IndirectReservoir resv
) {
    vec3 pnorm; float pdepth; uint matHash;
    
    loadLastGeometryInfo(lastCoord, pnorm, pdepth, matHash);
    if (inBound(lastCoord, rtxState.size)) {
        if (hash8bit(matId) == matHash) {
            if (dot(norm, pnorm) > 0.9 && reprojDepth < pdepth * 1.05) {
                resv = lastIndirectResv[(lastCoord.y / 2) * indSize().x + (lastCoord.x / 2)];
                return true;
            }
        }
    }
    /*
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            ivec2 coord = ivec2(lastCoord.x + i, lastCoord.y + j);
            loadLastGeometryInfo(coord, pnorm, pdepth, matHash);
            if (!inBound(coord, indSize())) {
                continue;
            }
            else if (hash8bit(matId) != matHash)
                continue;
            else if (dot(norm, pnorm) < 0.5 || reprojDepth  > pdepth * 1.05) {
                continue;
            }
            resv = lastIndirectResv[coord.y * indSize().x + coord.x];
            return true;
        }
    }
    */
    return false;
}

GISample newGISample() {
    GISample giSample;
    giSample.nv = vec3(100.0);
    giSample.L = vec3(0.0);
    return giSample;
}

bool GISampleValid(GISample giSample) {
    return giSample.nv.x < 1.1 && !hasNan(giSample.L);
}

void saveNewReservoir(IndirectReservoir resv) {
    thisIndirectResv[imageCoords.y * indSize().x + imageCoords.x] = resv;
}

void cacheTempReservoir(IndirectReservoir resv) {
    tempIndirectResv[imageCoords.y * indSize().x + imageCoords.x] = resv;
}

void pathTraceIndirect(
    State state, Ray ray,
    out float primSamplePdf, out vec3 primWo, out State primState, out GISample giSample
) {
    vec3 throughput = vec3(multiBounce ? 4.0 : 1.0);
    primWo = -ray.direction;
    primState = state;
    giSample = newGISample();

    state.mat.albedo = vec3(1.0);

    for (int depth = 1; depth <= rtxState.maxDepth; depth++) {
        vec3 wo = -ray.direction;

        if (depth > 1 && rtxState.MIS > 0) {
            vec3 Li, wi;
            float lightPdf = SampleDirectLight(state, Li, wi);

            if (!IsPdfInvalid(lightPdf)) {
                float BSDFPdf = Pdf(state, wo, state.ffnormal, wi);
                float weight = MIS(lightPdf, BSDFPdf);
                giSample.L += Li * BSDF(state, wo, state.ffnormal, wi) * absDot(state.ffnormal, wi) *
                    throughput / lightPdf * weight;
            }
        }

        vec3 sampleWi;
        float samplePdf;
        vec3 sampleBSDF = Sample(state, wo, state.ffnormal, sampleWi, samplePdf, prd.seed);

        if (IsPdfInvalid(samplePdf)) {
            break;
        }

        if (depth > 1) {
            if (!multiBounce) {
                return;
            }
            throughput *= sampleBSDF / samplePdf * absDot(state.ffnormal, sampleWi);
        }
        else {
            primSamplePdf = samplePdf;
            giSample.xv = state.position;
            giSample.nv = state.ffnormal;
        }

        ray.origin = OffsetRay(state.position, state.ffnormal);
        ray.direction = sampleWi;

        ClosestHit(ray);

        if (prd.hitT >= INFINITY - 1e-4) {
            if (depth > 1) {
                float lightPdf;
                vec3 Li = EnvEval(sampleWi, lightPdf);
                float weight = MIS(samplePdf, lightPdf);
                giSample.L += Li * throughput * weight;
            }
            // else {
            //     // Hack here. To let samples from the infinity light able to be temporally reused
            //     // giSample.matInfo = uvec2(0xFFFFFFFF, 0xFFFFFFFF);
            //     giSample.xs = state.position + sampleWi * INFINITY * 0.8;
            //     giSample.ns = -sampleWi;
            // }
            break;
        }

        state = GetState(prd, ray.direction);
        GetMaterials(state, ray);

        if (state.isEmitter) {
            if (depth > 1) {
                float lightPdf;
                vec3 Li = LightEval(state, prd.hitT, sampleWi, lightPdf);
                float weight = MIS(samplePdf, lightPdf);
                giSample.L += Li * throughput * weight;
            }
            // else {
            //     giSample.xs = state.position;
            //     giSample.ns = state.ffnormal;
            // }
            break;
        }

        if (depth == 1) {
            giSample.xs = state.position;
            giSample.ns = state.ffnormal;
        }

#ifndef RR
        float rrPcont = (1 >= RR_DEPTH) ? min(max(throughput.x, max(throughput.y, throughput.z)) * state.eta * state.eta + 0.001, 0.95) : 1.0;
        if (rand(prd.seed) >= rrPcont) {
            break;
        }
        throughput /= rrPcont;
#endif
    }
}

vec3 ReSTIRIndirect(float dist, float primSamplePdf, vec3 primWo, State primState, GISample giSample) {
    vec3 indirect = vec3(0.0);

    IndirectReservoir resv;
    resvReset(resv);
    // temporal reuse
    if (rtxState.ReSTIRState == eTemporal || rtxState.ReSTIRState == eSpatiotemporal) {
        float reprojDepth = length(sceneCamera.lastPosition - primState.position);
        ivec2 motionIdx = imageLoad(motionVector, imageCoords * 2).xy;
        findTemporalNeighbor(primState.ffnormal, dist, reprojDepth, primState.matID, motionIdx, resv);
    }

    float sampleWeight = 0.0;
    if (GISampleValid(giSample)) {
        giSample.pHat = pHatIndirect(giSample, primState, primWo);
        sampleWeight = (giSample.pHat / primSamplePdf);
        if (isnan(sampleWeight) || sampleWeight < 0.0) {
            sampleWeight = 0.0;
        }
    }
    resvUpdate(resv, giSample, sampleWeight, rand(prd.seed));

    resvCheckValidity(resv);
    resvClamp(resv, rtxState.reservoirClamp / 2);
    saveNewReservoir(resv);
   
    giSample = resv.giSample;
    if (!resvInvalid(resv) && GISampleValid(giSample)) {
        vec3 primWi = normalize(giSample.xs - giSample.xv);
        /*
        indirect = giSample.L * BSDF(primState, primWo, giSample.nv, primWi) * satDot(giSample.nv, primWi) *
            bigWIndirect(resv, primState, primWo);
            */
        indirect = giSample.L / giSample.pHat * resv.weight / float(resv.num);
        primState.mat.albedo = vec3(1.0);
        indirect *= BSDF(primState, primWo, giSample.nv, primWi) * absDot(giSample.nv, primWi);
    }

    if (hasNan(indirect)) {
        indirect = vec3(0.0);
    }
    return HDRToLDR(indirect);
}

void main() {
  imageCoords = ivec2(gl_GlobalInvocationID.xy);  //SampleSizzled();
  ivec2 imageRes = indSize();
  if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y) {
    return;
  }
  ivec2 p00 = imageCoords * 2 + ivec2(0, 0);
  ivec2 p10 = imageCoords * 2 + ivec2(1, 0);
  ivec2 p11 = imageCoords * 2 + ivec2(1, 1);
  ivec2 p01 = imageCoords * 2 + ivec2(0, 1);

  prd.seed = tea(indSize().x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, rtxState.time);
  Ray ray = raySpawn(imageCoords, imageRes);

#if TILED_MULTIBOUNCE
  if (gl_LocalInvocationIndex == 0) {
    multiBounce = rand(prd.seed) < MultiBounceProb;
  }
  barrier();
#endif

  State state;
  float depth;
  if (!getStateFromGbuffer(ray, state, depth)) {
#if PRE_UPSCALE
    imageStore(thisIndirectResultImage, p00, vec4(0.0));
    imageStore(thisIndirectResultImage, p10, vec4(0.0));
    imageStore(thisIndirectResultImage, p11, vec4(0.0));
    imageStore(thisIndirectResultImage, p01, vec4(0.0));
#else
    imageStore(thisIndirectResultImage, imageCoords, vec4(0.0));
#endif
    return;
  }
#if FETCH_GEOM_CHECK_4_SUBPIXELS
  state.position += state.ffnormal * 1e-3;
#else
  state.position += state.ffnormal * 1e-2;
#endif

  float primSamplePdf; vec3 primWo; State primState; GISample giSample;

  pathTraceIndirect(state, ray, primSamplePdf, primWo, primState, giSample);
  vec3 pixelColor = ReSTIRIndirect(depth, primSamplePdf, primWo, primState, giSample);
  pixelColor = clampRadiance(pixelColor);

  ivec2 motionIdx = imageLoad(motionVector, imageCoords * 2).xy;
  vec3 lastColor;
  if (inBound(motionIdx, rtxState.size)) {
    lastColor = imageLoad(lastIndirectResultImage, motionIdx / 2).rgb;
  }
  else {
    lastColor = pixelColor;
  }

  //vec4 c00 = vec4(mix(lastColor, pixelColor, 0.125), 1.0);
  vec4 c00 = vec4(pixelColor, 1.0);
#if !PRE_UPSCALE
  imageStore(thisIndirectResultImage, imageCoords, c00);
  return;
#else
  imageStore(thisIndirectResultImage, imageCoords * 2, c00);
  barrier();

  vec4 c10 = imageLoad(thisIndirectResultImage, p10 + ivec2(1, 0));
  vec4 c11 = imageLoad(thisIndirectResultImage, p11 + ivec2(1, 1));
  vec4 c01 = imageLoad(thisIndirectResultImage, p01 + ivec2(0, 1));
  barrier();
  imageStore(thisIndirectResultImage, p10, (c00 + c10) * 0.5);
  imageStore(thisIndirectResultImage, p11, (c00 + c10 + c11 + c01) * 0.25);
  imageStore(thisIndirectResultImage, p01, (c00 + c01) * 0.5);
#endif
  /*
  if(rtxState.frame > 0) {
    vec3 old_color = imageLoad(lastIndirectResultImage, imageCoords).xyz;
    vec3 new_result = mix(old_color, pixelColor, 1.0f / float(rtxState.frame + 1));
    if (rtxState.accumulate != 0) {
      imageStore(thisIndirectResultImage, imageCoords, vec4(new_result, 1));
    }
    else {
      imageStore(thisIndirectResultImage, imageCoords, vec4(pixelColor, 1.0));
    }
  } else {
    imageStore(thisIndirectResultImage, imageCoords, vec4(pixelColor, 0));
  }
  */
}

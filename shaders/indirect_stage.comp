/*
 * Copyright (c) 2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

//-------------------------------------------------------------------------------------------------
// Ray Query compute shader implementating the path tracer.

#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#include "host_device.h"

layout(push_constant) uniform _RtxState {
  RtxState rtxState;
};

#include "globals.glsl"

PtPayload prd;
ShadowHitPayload shadow_payload;
ivec2 imageCoords;

#include "layouts.glsl"
#include "random.glsl"
#include "common.glsl"
#include "traceray_rq.glsl"

#include "pathtrace.glsl"

#define FIREFLIES 1

#ifndef SWIZZLED
layout(local_size_x = 8, local_size_y = 8) in;
#else
layout(local_size_x = 32, local_size_y = 2) in;
#extension GL_EXT_shader_8bit_storage : enable  // Using uint_8 ...
ivec2 SampleSizzled() {
  // Sampling Swizzling
  // Convert 32x2 to 8x8, where the sampling will follow how invocation are done in a subgroup.
  // layout(local_size_x = 32, local_size_y = 2) in;
  ivec2 base = ivec2(gl_WorkGroupID.xy) * 8;
  ivec2 subset = ivec2(int(gl_LocalInvocationID.x) & 1, int(gl_LocalInvocationID.x) / 2);
  subset += gl_LocalInvocationID.x >= 16 ? ivec2(2, -8) : ivec2(0, 0);
  subset += ivec2(gl_LocalInvocationID.y * 4, 0);
  return base + subset;
}
#endif

bool getStateFromGbuffer(Ray ray, out State state, out float depth) {
  uvec4 gInfo = imageLoad(thisGbuffer, imageCoords);
  depth = uintBitsToFloat(gInfo.x);
  if(depth >= INFINITY - EPS * 10.0)
    return false;
  state.position = ray.origin + ray.direction * depth;
  state.normal = decompress_unit_vec(gInfo.y);
  state.ffnormal = dot(state.normal, ray.direction) <= 0.0 ? state.normal : -state.normal;

  // Filling material structures
  state.mat.albedo = unpackUnorm4x8(gInfo.w).xyz;
  vec4 matInfo = unpackUnorm4x8(gInfo.z);
  state.mat.metallic = matInfo.x;
  state.mat.roughness = matInfo.y;
  state.mat.ior = matInfo.z * MAX_IOR_MINUS_ONE + 1.f;
  state.mat.transmission = matInfo.w;
  state.matID = gInfo.w >> 24; // hashed matarial id
  return true;
}

uvec2 encodeMaterialInfo(State state) {
    uvec2 matInfo;
    matInfo.x = packUnorm4x8(vec4(state.mat.metallic, state.mat.roughness, (state.mat.ior-1.0) / MAX_IOR_MINUS_ONE, state.mat.transmission));
    matInfo.y = packUnorm4x8(vec4(state.mat.albedo, 1.0)) & 0xFFFFFF; //agbr
    matInfo.y += hash8bit(state.matID);
    return matInfo;
}

float MIS(float f, float g) {
    return (rtxState.MIS > 0) ? powerHeuristic(f, g) : 1.0;
}

bool findTemporalNeighbor(
    vec3 norm, float depth, float reprojDepth, uint matId, ivec2 lastCoord, out IndirectReservoir resv
) {

    vec3 pnorm; float pdepth; uint matHash;

    loadLastGeometryInfo(lastCoord, pnorm, pdepth, matHash);
    if (lastCoord.x >= 0 && lastCoord.x < rtxState.size.x &&
        lastCoord.y >= 0 && lastCoord.y < rtxState.size.y) {
        if (hash8bit(matId) == matHash) {
            if (dot(norm, pnorm) > 0.9 && reprojDepth < pdepth * 1.05) {
                resv = lastIndirectResv[lastCoord.y * rtxState.size.x + lastCoord.x];
                return true;
            }
        }
    }
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            ivec2 coord = ivec2(lastCoord.x + i, lastCoord.y + j);
            loadLastGeometryInfo(coord, pnorm, pdepth, matHash);
            if (coord.x < 0 || coord.x >= rtxState.size.x ||
                coord.y < 0 || coord.y >= rtxState.size.y) {
                continue;
            }
            else if (hash8bit(matId) != matHash)
                continue;
            else if (dot(norm, pnorm) < 0.9 || reprojDepth  > pdepth * 1.05) {
                continue;
            }
            resv = lastIndirectResv[coord.y * rtxState.size.x + coord.x];
            return true;
        }
    }
    return false;
}
bool findSpatialNeighbor(vec3 norm, float depth, uint matId, out IndirectReservoir resv) {
    const float Radius = 30.0;

    vec2 p = toConcentricDisk(vec2(rand(prd.seed), rand(prd.seed)));
    int px = int(float(imageCoords.x + p.x) + 0.5);
    int py = int(float(imageCoords.y + p.y) + 0.5);
    int pidx = py * rtxState.size.x + px;

    vec3 pnorm; float pdepth; uint matHash;
    loadLastGeometryInfo(imageCoords, pnorm, pdepth, matHash);

    if (px < 0 || px >= rtxState.size.x || py < 0 || py >= rtxState.size.y) {
        return false;
    }
    else if (hash8bit(matId) != matHash)
        return false;
    else if (dot(norm, pnorm) < 0.9 || depth > pdepth * 1.05) {
        return false;
    }
    resv = tempIndirectResv[pidx];
    return true;
}
bool mergeSpatialNeighbors(vec3 norm, float depth, uint matId, out IndirectReservoir resv) {
    bool valid = false;
    resvReset(resv);
    for (int i = 0; i < 5; i++) {
        IndirectReservoir spatial;
        if (findSpatialNeighbor(norm, depth, matId, spatial)) {
            if (!resvInvalid(spatial)) {
                resvMerge(resv, spatial, rand(prd.seed));
                valid = true;
            }
        }
    }
    return valid;
}

float pHatIndirect(GISample giSample, State state, vec3 wo) {
    // return resvToScalar(giSample.L);

    vec3 wi = normalize(giSample.xs - giSample.xv);
    return resvToScalar(giSample.L * BSDF(state, wo, state.ffnormal, wi) * satDot(giSample.nv, wi));
}

float bigWIndirect(IndirectReservoir resv, State state, vec3 wo) {
    return resv.weight / (pHatIndirect(resv.giSample, state, wo) * float(resv.num));
}

GISample newGISample() {
    GISample giSample;
    giSample.nv = vec3(100.0);
    giSample.L = vec3(0.0);
    return giSample;
}

bool GISampleValid(GISample giSample) {
    return giSample.nv.x < 1.1 && !hasNan(giSample.L);
}

void saveNewReservoir(IndirectReservoir resv) {
    thisIndirectResv[imageCoords.y * rtxState.size.x + imageCoords.x] = resv;
}

void cacheTempReservoir(IndirectReservoir resv) {
    tempIndirectResv[imageCoords.y * rtxState.size.x + imageCoords.x] = resv;
}

vec3 ReSTIRIndirect(State state, Ray ray, float dist) {
    vec3 throughput = vec3(1.0);
    float primSamplePdf;
    vec3 primWo = -ray.direction;
    State primState = state;

    GISample giSample = newGISample();

    // path tracing
    for (int depth = 1; depth <= rtxState.maxDepth; depth++) {
        vec3 wo = -ray.direction;

        // add direct lighting
        if (depth > 1) {
            vec3 Li, wi;
            float lightPdf = SampleDirectLight(state, Li, wi);

            if (!IsPdfInvalid(lightPdf)) {
                float BSDFPdf = Pdf(state, wo, state.ffnormal, wi);
                float weight = MIS(lightPdf, BSDFPdf);
                giSample.L += Li * BSDF(state, wo, state.ffnormal, wi) * absDot(state.ffnormal, wi) *
                    throughput / lightPdf * weight;
            }
        }

        vec3 sampleWi;
        float samplePdf;
        vec3 sampleBSDF = Sample(state, wo, state.ffnormal, sampleWi, samplePdf, prd.seed);

        if (IsPdfInvalid(samplePdf)) {
            break;
        }

        if (depth > 1) {
            throughput *= sampleBSDF / samplePdf * absDot(state.ffnormal, sampleWi);
        }
        else {
            primSamplePdf = samplePdf;
            giSample.xv = state.position;
            giSample.nv = state.ffnormal;
        }

        ray.origin = OffsetRay(state.position, state.ffnormal);
        ray.direction = sampleWi;

        ClosestHit(ray);

        if (prd.hitT >= INFINITY - 1e-4) {
            if (depth > 1) {
                float lightPdf;
                vec3 Li = EnvEval(sampleWi, lightPdf);
                float weight = MIS(samplePdf, lightPdf);
                giSample.L += Li * throughput * weight;
            }
            // else {
            //     // Hack here. To let samples from the infinity light able to be temporally reused
            //     // giSample.matInfo = uvec2(0xFFFFFFFF, 0xFFFFFFFF);
            //     giSample.xs = state.position + sampleWi * INFINITY * 0.8;
            //     giSample.ns = -sampleWi;
            // }
            // if (depth == 2) {
            //     giSample.ws = sampleWi;
            // }
            break;
        }

        state = GetState(prd, ray.direction);
        GetMaterials(state, ray);

        if (state.isEmitter) {
            if (depth > 1) {
                float lightPdf;
                vec3 Li = LightEval(state, prd.hitT, sampleWi, lightPdf);
                float weight = MIS(samplePdf, lightPdf);
                giSample.L += Li * throughput * weight;
            }
            // else {
            //     giSample.xs = state.position;
            //     giSample.ns = state.ffnormal;
            // }
            // if (depth == 2) {
            //     giSample.ws = sampleWi;
            // }
            break;
        }

        if (depth == 1) {
            giSample.xs = state.position;
            giSample.ns = state.ffnormal;
        }
        // if (depth == 2) {
        //     giSample.ws = sampleWi;
        // }

#ifdef RR
        float rrPcont = (1 >= RR_DEPTH) ? min(max(throughput.x, max(throughput.y, throughput.z)) * state.eta * state.eta + 0.001, 0.95) : 1.0;
        if (rand(prd.seed) >= rrPcont) {
            break;
        }
        throughput /= rrPcont;
#endif
    }

    IndirectReservoir resv;
    resvReset(resv);

    float sampleWeight = 0.0;
    if (GISampleValid(giSample)) {
        giSample.pHat = pHatIndirect(giSample, primState, primWo);
        sampleWeight = (giSample.pHat / primSamplePdf);
        if (isnan(sampleWeight) || sampleWeight < 0.0) {
            sampleWeight = 0.0;
        }
        // giSample.matInfo = encodeMaterialInfo(state);
    }
    resvUpdate(resv, giSample, sampleWeight, rand(prd.seed));

    IndirectReservoir thisResv = resv;

    // temporal reuse
    if (rtxState.ReSTIRState == eTemporal || rtxState.ReSTIRState == eSpatiotemporal) {
        float reprojDepth = length(sceneCamera.lastPosition - primState.position);
        ivec2 motionIdx = imageLoad(motionVector, imageCoords).xy;

        IndirectReservoir temporal;
        if (findTemporalNeighbor(primState.ffnormal, dist, reprojDepth, primState.matID, motionIdx, temporal)) {
            if (!resvInvalid(temporal)) {
                vec3 primWi = normalize(temporal.giSample.xs - primState.position);
                // if (resvInvalid(resv) || resvToScalar(temporal.giSample.L * BSDF(primState, primWo, temporal.giSample.nv, primWi) * absDot(temporal.giSample.nv, primWi)) > 0.05)
                    resvMerge(resv, temporal, rand(prd.seed));
            }
        }
    }

    vec3 indirect = vec3(0.0);

    giSample = resv.giSample;
    if (!resvInvalid(resv) && GISampleValid(giSample)) {
        vec3 primWi = normalize(giSample.xs - primState.position);
        /*
        indirect = giSample.L * BSDF(primState, primWo, giSample.nv, primWi) * satDot(giSample.nv, primWi) *
            bigWIndirect(resv, primState, primWo);
            */
        // if (giSample.matInfo.x != 0xFFFFFFFF){
        //     state.position = giSample.xs;
        //     state.normal = giSample.ns;
        //     state.ffnormal = dot(state.normal, primWi) <= 0.0 ? state.normal : -state.normal;
        //     state.mat.albedo = unpackUnorm4x8(giSample.matInfo.x).xyz;
        //     vec4 matInfo = unpackUnorm4x8(giSample.matInfo.y);
        //     state.mat.metallic = matInfo.x;
        //     state.mat.roughness = matInfo.y;
        //     state.mat.ior = matInfo.z * MAX_IOR_MINUS_ONE + 1.f;
        //     state.mat.transmission = matInfo.w;
        //     giSample.L *= BSDF(state, -primWi, state.ffnormal, giSample.ws) * absDot(giSample.ns, giSample.ws);
        // }
        indirect = giSample.L * BSDF(primState, primWo, giSample.nv, primWi) * absDot(giSample.nv, primWi);
    }

    if (hasNan(indirect)) {
        indirect = vec3(0.0);
    }

    // store the reservoir before spatial reuse
    resvCheckValidity(resv);
    resvClamp(resv, rtxState.RISSampleNum * rtxState.reservoirClamp);

    if (!resvInvalid(thisResv) && 
        ((abs(resvToScalar(indirect) - resv.giSample.pHat) > 0.1) || 
        resv.giSample.pHat < 0.1)) {
        saveNewReservoir(thisResv);
    }
    else saveNewReservoir(resv);
    
    indirect = indirect / giSample.pHat * resv.weight / float(resv.num);

    // spatial reuse
    // if (rtxState.ReSTIRState == eSpatial || rtxState.ReSTIRState == eSpatiotemporal) {
    //     IndirectReservoir spatial;
    //     resvReset(spatial);

    //     barrier();
    //     cacheTempReservoir(resv);
    //     barrier();

    //     IndirectReservoir spatialAggregate;
    //     if (mergeSpatialNeighbors(primState.ffnormal, dist, primState.matID, spatialAggregate)) {
    //         if (!resvInvalid(spatialAggregate)) {
    //             resvMerge(spatial, spatialAggregate, rand(prd.seed));
    //         }
    //     }
    //     barrier();
    //     resvCheckValidity(resv);
    //     cacheTempReservoir(resv);
    //     barrier();

    //     if (mergeSpatialNeighbors(primState.ffnormal, dist, primState.matID, spatialAggregate)) {
    //         if (!resvInvalid(spatialAggregate)) {
    //             resvMerge(spatial, spatialAggregate, rand(prd.seed));
    //         }
    //     }

    //     if (!resvInvalid(spatial)) {
    //         //resvClamp(spatial, 128);
    //         resvMerge(resv, spatial, rand(prd.seed));
    //     }
    // }
    return indirect;
}

void main() {
  ivec2 imageRes = rtxState.size;
  imageCoords = ivec2(gl_GlobalInvocationID.xy);  //SampleSizzled();
  if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y) {
    return;
  }

  prd.seed = tea(rtxState.size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, rtxState.time);
  Ray ray = raySpawn(imageCoords, imageRes);

  State state;
  float depth;
  if (!getStateFromGbuffer(ray, state, depth)) {
    imageStore(thisIndirectResultImage, imageCoords, vec4(0.0));
    return;
  }
  //state.position = OffsetRay(state.position, state.ffnormal);

  vec3 pixelColor = ReSTIRIndirect(state, ray, depth);
  pixelColor = clampRadiance(pixelColor);

  if(rtxState.frame > 0) {
    vec3 old_color = imageLoad(lastIndirectResultImage, imageCoords).xyz;
    vec3 new_result = mix(old_color, pixelColor, 1.0f / float(rtxState.frame + 1));
    if (rtxState.accumulate != 0) {
      imageStore(thisIndirectResultImage, imageCoords, vec4(new_result, 1));
    }
    else {
      imageStore(thisIndirectResultImage, imageCoords, vec4(pixelColor, 1.0));
    }
  } else {
    imageStore(thisIndirectResultImage, imageCoords, vec4(pixelColor, 0));
  }
}
